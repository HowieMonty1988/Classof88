<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>High School Stories Recorder</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 24px; max-width: 980px; }
    h1 { font-size: 34px; margin: 0 0 14px; }
    .warn { background: #fff7e6; border: 1px solid #ffd59a; padding: 14px; border-radius: 12px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 18px; margin-top: 16px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 820px) { .grid { grid-template-columns: 1fr; } }
    label { display: block; font-weight: 700; margin: 12px 0 6px; }
    input, textarea {
      width: 100%;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #cfcfcf;
      font-size: 14px;
      box-sizing: border-box;
    }
    textarea { min-height: 90px; resize: vertical; }
    .row { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 14px; }
    button {
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid #111;
      background: #111;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    button.secondary { background: #fff; color: #111; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .status { margin-top: 10px; font-weight: 700; }
    .muted { font-weight: 400; color: #444; }
    .timer { font-variant-numeric: tabular-nums; }
    audio { width: 100%; margin-top: 12px; }
    .small { font-size: 13px; }
  </style>
</head>
<body>
  <h1>High School Stories Recorder</h1>

  <div class="warn small">
    <div><b>Instructions.</b> Fill in your info, press <b>Start Recording</b>, tell your story, then press <b>Stop</b>. Finally press <b>Submit Recording</b>.</div>
    <div style="margin-top:6px;">
      <b>Privacy option.</b> If you want your story kept private and not used in a book, say that clearly at the start of your recording.
    </div>
    <div style="margin-top:6px;">
      <b>Time note.</b> Long recordings can fail if your phone sleeps or the tab reloads. Keep the screen awake. If you have a long story, do it in 5 to 10 minute parts.
    </div>
  </div>

  <div class="card">
    <div class="grid">
      <div>
        <label for="name">Your name</label>
        <input id="name" type="text" placeholder="Example: Steve Hauer" autocomplete="name" />
      </div>
      <div>
        <label for="year">Graduation year (optional)</label>
        <input id="year" type="text" placeholder="Example: 1988" inputmode="numeric" />
      </div>
      <div>
        <label for="email">Email (optional)</label>
        <input id="email" type="email" placeholder="Example: you@email.com" autocomplete="email" />
      </div>
      <div>
        <label for="phone">Phone (optional)</label>
        <input id="phone" type="tel" placeholder="Example: 5551234567" autocomplete="tel" />
      </div>
    </div>

    <label for="subject">Story subject or quick description</label>
    <textarea id="subject" placeholder="Example: The bonfire party, Homecoming night, The coach story, The prank that went too far"></textarea>

    <div class="row">
      <button id="startBtn">Start Recording</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="submitBtn" class="secondary" disabled>Submit Recording</button>
      <button id="resetBtn" class="secondary" disabled>Reset</button>
    </div>

    <div class="status" id="statusLine">
      Status: <span class="muted" id="statusText">Ready</span>
      <span style="margin-left:12px;">Time: <span class="timer" id="timer">00:00</span></span>
    </div>

    <audio id="playback" controls></audio>

    <div class="small muted" style="margin-top:10px;">
      Best browser, Chrome or Edge on desktop or Android. iPhone Safari can be inconsistent for long recordings.
    </div>
  </div>

  <script>
    const WEB_APP_URL = "https://script.google.com/macros/s/AKfycbxsSrMHR2D97u5cnr8SPzHgjnvxbqwWryIEy2VnBw2dlyb7l6FsWzskeIaQjeaKHbHT/exec";

    const els = {
      name: document.getElementById("name"),
      year: document.getElementById("year"),
      email: document.getElementById("email"),
      phone: document.getElementById("phone"),
      subject: document.getElementById("subject"),
      startBtn: document.getElementById("startBtn"),
      stopBtn: document.getElementById("stopBtn"),
      submitBtn: document.getElementById("submitBtn"),
      resetBtn: document.getElementById("resetBtn"),
      statusText: document.getElementById("statusText"),
      timer: document.getElementById("timer"),
      playback: document.getElementById("playback"),
    };

    let mediaRecorder = null;
    let streamRef = null;
    let chunks = [];
    let recordingBlob = null;
    let recordingUrl = null;

    let startTimeMs = 0;
    let timerHandle = null;

    function setStatus(text) {
      els.statusText.textContent = text;
    }

    function formatTime(totalSeconds) {
      const m = Math.floor(totalSeconds / 60);
      const s = totalSeconds % 60;
      return String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
    }

    function startTimer() {
      startTimeMs = Date.now();
      els.timer.textContent = "00:00";
      timerHandle = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTimeMs) / 1000);
        els.timer.textContent = formatTime(elapsed);
      }, 250);
    }

    function stopTimer() {
      if (timerHandle) clearInterval(timerHandle);
      timerHandle = null;
    }

    function cleanupAudioUrl() {
      if (recordingUrl) URL.revokeObjectURL(recordingUrl);
      recordingUrl = null;
    }

    function setButtons(state) {
      els.startBtn.disabled = !state.canStart;
      els.stopBtn.disabled = !state.canStop;
      els.submitBtn.disabled = !state.canSubmit;
      els.resetBtn.disabled = !state.canReset;
    }

    function resetAll() {
      try {
        if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
      } catch (e) {}

      mediaRecorder = null;
      chunks = [];
      recordingBlob = null;

      stopTimer();
      els.timer.textContent = "00:00";

      cleanupAudioUrl();
      els.playback.removeAttribute("src");
      els.playback.load();

      if (streamRef) {
        streamRef.getTracks().forEach(t => t.stop());
        streamRef = null;
      }

      setButtons({ canStart: true, canStop: false, canSubmit: false, canReset: false });
      setStatus("Ready");
    }

    async function getSupportedMimeType() {
      const candidates = [
        "audio/webm;codecs=opus",
        "audio/webm",
        "audio/ogg;codecs=opus",
        "audio/ogg"
      ];
      for (const t of candidates) {
        if (window.MediaRecorder && MediaRecorder.isTypeSupported(t)) return t;
      }
      return "";
    }

    function buildFilename() {
      const clean = (s) => String(s || "").trim().replace(/[^a-z0-9]+/gi, "_").replace(/^_+|_+$/g, "");
      const cleanNum = (s) => String(s || "").replace(/[^0-9]+/g, "");
      const name = clean(els.name.value) || "Anonymous";
      const year = cleanNum(els.year.value);
      const stamp = new Date().toISOString().replace(/[:.]/g, "").slice(0, 15);
      const parts = ["ClassOf88", name];
      if (year) parts.push(year);
      parts.push(stamp);
      return parts.join("_");
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = () => reject(new Error("FileReader failed."));
        reader.onload = () => {
          const result = String(reader.result || "");
          const comma = result.indexOf(",");
          if (comma === -1) return reject(new Error("Unexpected base64 format."));
          resolve(result.slice(comma + 1));
        };
        reader.readAsDataURL(blob);
      });
    }

    els.startBtn.addEventListener("click", async () => {
      try {
        resetAll();

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          alert("This browser does not support microphone recording.");
          return;
        }

        const mimeType = await getSupportedMimeType();
        streamRef = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
        });

        chunks = [];
        recordingBlob = null;

        mediaRecorder = new MediaRecorder(streamRef, mimeType ? { mimeType } : undefined);

        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) chunks.push(e.data);
        };

        mediaRecorder.onstop = () => {
          stopTimer();

          const type = (mediaRecorder && mediaRecorder.mimeType) ? mediaRecorder.mimeType : "audio/webm";
          recordingBlob = new Blob(chunks, { type });

          cleanupAudioUrl();
          recordingUrl = URL.createObjectURL(recordingBlob);
          els.playback.src = recordingUrl;

          if (streamRef) {
            streamRef.getTracks().forEach(t => t.stop());
            streamRef = null;
          }

          setButtons({ canStart: true, canStop: false, canSubmit: true, canReset: true });
          setStatus("Ready to submit");
        };

        mediaRecorder.start();
        setButtons({ canStart: false, canStop: true, canSubmit: false, canReset: true });
        setStatus("Recording");
        startTimer();
      } catch (err) {
        alert("Microphone access failed. Allow mic permissions and try again.");
        resetAll();
      }
    });

    els.stopBtn.addEventListener("click", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        setStatus("Stopping");
        mediaRecorder.stop();
      }
    });

    els.resetBtn.addEventListener("click", () => resetAll());

    els.submitBtn.addEventListener("click", async () => {
      try {
        if (!recordingBlob) {
          alert("No recording found. Press Start Recording first.");
          return;
        }

        setButtons({ canStart: false, canStop: false, canSubmit: false, canReset: false });
        setStatus("Uploading to Google Drive");

        const base64 = await blobToBase64(recordingBlob);
        const ext = recordingBlob.type.includes("ogg") ? "ogg" : "webm";
        const filename = buildFilename() + "." + ext;

        const elapsedSec = Math.floor((Date.now() - startTimeMs) / 1000);
        const payload = {
          filename,
          mimeType: recordingBlob.type || "audio/webm",
          data: base64,
          name: els.name.value || "",
          year: els.year.value || "",
          email: els.email.value || "",
          phone: els.phone.value || "",
          subject: els.subject.value || "",
          durationSec: elapsedSec
        };

        /*
          Important CORS detail:
          We intentionally send Content-Type as text/plain so the browser does NOT do a CORS preflight.
          Apps Script will still receive e.postData.contents, and your doPost can JSON.parse it.
        */
        const res = await fetch(WEB_APP_URL, {
          method: "POST",
          headers: { "Content-Type": "text/plain;charset=utf-8" },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          const text = await res.text();
          throw new Error("Submit failed. " + res.status + " " + text);
        }

        const json = await res.json();
        if (!json || json.ok !== true) {
          throw new Error("Submit error. " + (json && json.error ? json.error : "Unknown server response."));
        }

        setStatus("Submitted. Saved to Drive.");
        setButtons({ canStart: true, canStop: false, canSubmit: false, canReset: true });
      } catch (err) {
        setStatus("Failed to fetch");
        setButtons({ canStart: true, canStop: false, canSubmit: true, canReset: true });
        alert(String(err && err.message ? err.message : err));
      }
    });

    window.addEventListener("beforeunload", () => cleanupAudioUrl());
    resetAll();
  </script>
</body>
</html>

